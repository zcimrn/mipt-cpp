### MatrixArray

*В этом задании вам необходимо реализовать шаблонный класс для работы с матрицами фиксированного размера. Последнее
означает, что размеры матрицы должны передаваться в виде шаблонных параметров-целых чисел (non-type template
parameters), и для конкретного объекта не могут быть изменены в течении работы программы. С одной стороны, это
накладывает ограничения - размер матриц должен быть жестко задан на этапе компиляции и пользователь не имеет возможности
его менять. Кроме того, изменения параметров матриц будут требовать повторной компиляции исходного кода, использующего
эти матрицы. С другой стороны, так как размеры матрицы - константы времени компиляции, мы имеем возможность использовать
нединамические массивы (что заметно ускоряет работу с матрицами), компилятор имеет больше возможностей для оптимизации
кода, а неправильная работа с матрицами (умножение матриц неподходящих размеров, обращение неквадратных матриц и т.п.)
будет детектироваться еще на этапе сборки программы, а не во время исполнения.*

#### Детали реализации

Требуется реализовать шаблонный класс `Matrix`, принимающий в качестве шаблонных параметров тип хранимых элементов,
число строк матрицы и число столбцов. Так как шаблонные параметры - это константы времени компиляции, элементы матрицы
можно хранить в двумерном C-style массиве (`std::array` в этом задании пока запрещен). Это поле-массив должно быть
публичным для корректной работы агрегатной инициализации.

Для работы с матрицей предлагается реализовать следующие методы:
* `RowsNumber()` и `ColumnsNumber()`, возвращающие число строк и столбцов соответственно;
* Операция `()` ("круглые скобки") для доступа к элементам матрицы и возможности их изменения
  (подумайте, почему не `[]`);
* Метод `At`, аналогичный предыдущему пункту, но бросающий исключение `MatrixOutOfRange` в случае выхода за границы
  матрицы;
* Функцию `GetTransposed(matrix)`, возвращающую транспонированную версию переданной матрицы;
* Операции сложения, вычитания умножения матриц и их присваивающие версии. Обратите внимание, что эти операции применимы
  не к любым парам матриц!;
* Операции умножения (слева и справа) и деления на число, а также их присваивающие версии;
* Операции сравнения на равенство и неравенство двух матриц одинакового размера;
* Операции ввода из потока и вывода в поток.

Пример:

```c++
Matrix<int, 2, 3> a{{{1, 2, 3}, {4, 5, 6}}};
Matrix<int, 3, 2> b = GetTransposed(a);
// a + b      CE
a + a;     // Ok
// a * a      CE 
a * b;     // Ok
// a *= b  // CE - в матрицу a нельзя присвоить матрицу другого размера
b *= Matrix<int, 2, 2>{1, 2, 3, 4}; // Ok

std::cout << a;
```

```
1 2 3
4 5 6
```

**Замечания.**

1. Решение должно состоять из одного файла `matrix.h`.

2. В задаче есть открытые и закрытые тесты. Перед отправкой решения проверяйте его на открытых тестах (чуда не будет,
   если есть ошибка в публичных тестах, то она проявится и на более сложных приватных).

3. Помните о константных и неконстантных методах.

4. "Бросить исключение типа E" значит - написать строку throw E{};. В этот момент выполнение функции прекращается и,
   если исключение не будет обработано, программа завершится аварийно. Тестирующий код корректно обработает эту ошибку, вам
   этого делать не нужно.

5. Методы этого и дополнительного задания (ниже) необязательно реализовывать наиболее эффективным способом. В первую
   очередь проверяется правильность реализации.

---

### Дополнительная часть

Для работы с квадратными матрицами есть множество методов не применимых к матрицам произвольного размера. Тем не менее
так как размеры матриц известны заранее, мы можем на этапе компиляции проверять внутри них корректность размера.

Дополнительно реализуйте:

* Функцию `Transpose(matrix)`, который транспонирует *исходную* матрицу, изменяя ее (ясно, что транспонировать без
  изменения размера можно только квадратные матрицы);
* Функцию `Trace()` - подсчет следа матрицы;
* Функцию `Determinant()` - детерминант матрицы;
* Функции `GetInversed()` и `Inverse()` для обращения матриц (первый метод возвращает обратную, а второй изменяет
  исходную матрицу).


При попытке обращения вырожденной матрицы необходимо бросать исключение `MatrixIsDegenerateError`.

*Важно:* если вы выполнили это задание, добавьте в файл `matrix.h` следующую строку, чтобы в тесты была включена
проверка этого задания.
```c++
#define MATRIX_SQUARE_MATRIX_IMPLEMENTED
```
